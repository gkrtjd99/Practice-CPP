# Chapter03 Object, Type, Value

## 복습문제

### 프롬프트는 무엇인가?
사용자에게 특정 동작을 수행하도록 유도하는 메시지를 의미한다.
예를 들어 `cout << "Please enter your first name (followed by 'enter'):\n"` 이와 같이 사용자에게 입력을 요청하는 메시지가 프롬프트다.
### 변수의 값을 입력 받을 때 어떤 연산자를 쓰나?
`>>` 연산자를 사용한다.
### `member`라는 정수 타입의 값을 사용자에게 입력받을 때 사용자에게 입력을 요청하는 메시지를 출력하고, 프로그램에서 입력을 받아들이는 두 줄의 코드를 어떻게 작성하는가?
```
cout << "정수 값을 입력해주세요: ";
cin >> member;
```
### `\n`의 의미와 사용 목적은 무엇인가?
새 줄(Newline)을 나타내는 특수 문자다. 출력시 커서를 다음주의 시작 부분으로 이동시키는 역할을 한다.
### 문자열 입력을 중단시키는 입력은 무엇인가?
공백(whitepace, 새 줄, 탭 문자 등)에 의해 입력이 중단된다.
### 정수 입력을 중단시키는 입력은 무엇인가?
정수 입력은 공백문자 외에 숫자가 아닌 문자가 들어오면 중단된다.
### 다음 세 줄을 한줄의 코드로 작성하자
```
cout << "Hello, ";
cout << first_name;
cout << "!\n";
```
```
cout << "Hello, " << first_name << "!\n";
```
### 객체는 무엇인가?
객체는 컴퓨터 메모리에서 정보를 저장하기 위해 할당된 영역으로, 저장할 수 있는 정보의 종류를 지정하는 타입(type)을 가진다. 이름이 있는 객체를 변수(variable)라고 한다.
### 리터럴은 무엇인가?
타입(type)의 값을 직접적으로 표현하는 표기법이다.
예를 들어, `10`은 정수 리터럴, `3.14`는 부동소수점 리터럴, `'a'`는 문자 리터럴, `"Hello"`는 문자열 리터럴이다.
### 리터럴의 종류에는 무엇이 있는가?
- 정수(int) : 39, 1234
- 부동 소수점(double) : 3.5, 1.23e3
- 문자(char) : 'a', '\n'
- 문자열(string) : "Annemarie", "Hello, World!\n"
- 논리(bool) : true, false
### 변수란 무엇인가?
변수는 컴퓨터 메모리에서 정보를 저장하기 위해 할당된 영역으로, 저장할 수 있는 정보의 종류를 지정하는 타입(type)을 가진다.
### `char`와 `int`, `double`의 일반적인 크기는 얼마인가?
- `char`는 1바이트(8비트)
- `int`는 4바이트(32비트)
- `double`은 8바이트(62비트)
### `int`와 `string` 등 메모리 상의 작은 개체 크기를 나타내는 단위는 무엇인가?
메모리 상의 작은 개체 크기를 나타내는 단위는 `바이트(byte)`이다.
### `=`와 `==`의 차이점은 무엇인가?
`=`는 대입(assignment) 연산자다. 변수에 새로운 값을 할당한다.
`==`는 같음(equality) 연산자다. 두 값이 서로 같은지 비교한다.
결과는 true/false로 반환된다.
### 정의(definition)란 무엇인가?
정의(definition)는 프로그램에 새로운 이름을 도입하고, 해당 변수를 위한 메모리를 할당하는 문장이다.
### 초기화는 무엇이고, 대입과는 어떻게 다른가?
**초기화(initialization)**는 변수에 처음 값을 할당하는 것이다. 변수가 생성될 때 동시에 이루어진다.
**대입(assignment)**은 이미 값이 있는 변수에 새로운 값을 할당하는 것이다.
### 문자열 연결은 무엇이고, C++에서는 어떻게 사용하는가?
문자열 연결은 두개 이상의 문자열으 하나로 합치는 연산이다.
C++에서는 `+`연산자를 사용하여 문자열을 연결할 수 있다.
### 아래 이름 중에서 C++에서 합법적인 이름은 무엇인가? 합법직이지 않다면 그 이유는 무엇인가?
```
This_little_pig     This_1_is fine      2_For_1_special
latest thing        the_$12_method      _this_is_ok
MiniMineMine        number              correct?
```
변수 이름 규칙
- 이름의 시작은 알파벳 문자로 시작해야함.
- 알파벳문자, 숫자, 밑줄만 포함할 수 있다.
위 9개 중 합법적인 이름은 다음과 같다
`This_little_pig`, `MiniMineMine`, `number`
이 외에는 합법적이지가 않다
- 숫자로 시작 `2_For_1_special`
- 특수문자 사용 `the_$12_method`, `correct?`
- 공백사용 `This_1_is fine`, `latest thing`
- 밑줄로 시작 `_this_is_ok` (사용은 가능하나 밑줄로 시작하는 이름은 구현 및 시스템 엔터티를 위해 예약되어 있음)
### 합법적이지만 혼동을 야기할 수 있으므로 사용하지 말아야 할 이름 5가지의 예를 들어보자
1. `Name`, `nameS` : 대소문자만 다르게하여 혼동을 줄 수 있음.
2. `foo`, `f00`, `f1` : 숫자와 문자, 대문자 등 쉽게 혼용되는 문자를 사용하면 오타, 오독을 유발할 수 있음.
3. `int string = 7;` : 표준 라이브러리에 `string`타입이 정의되어 있음. 일반적으로 사용되는 이름을 재사용하면 라이브러리 기능 등을 사용할 때 문제가 될 수 있음.
4. `ALL_CAPITAL` : 모든 대문자로 이루어진 이름은 매크로로 예약되어 있어 사용하지 않는게 좋음.
5. `the_number_of_elements` : 나치게 긴 이름은 입력하기 어렵고, 화면에 맞지 않으며, 빠르게 읽기 어렵다.
### 이름을 선택하는 좋은 규칙으로 무엇이 있을까?
- 의미 있는 이름 선택 - : 프로그램의 목적을 이해하는 데 도움이 되는 이름을 선택
- 약어 및 두문자어는 신중하게 사용 : 약어와 두문자어는 혼동을 줄 수 있으므로 아껴서 사용
- 짧은 이름은 관례적으로 사용: x, i와 같은 짧은 이름은 관례적인 용도(예: 지역 변수, 루프 인덱스)에서만 의미
- 지나치게 긴 이름 피하기: 너무 긴 이름은 입력하고 읽기 어려움
- 모든 대문자 이름 피하기: 매크로에 예약되어 있어 혼동을 피하기 위해 모든 대문자로 된 이름은 사용하지 않는 것이 좋음
- 오타, 오독, 혼동을 유발하기 쉬운 이름 피하기: 0(숫자)과 o(문자), 1(숫자)과 l(문자) 등 쉽게 혼동될 수 있는 문자 사용 자제
### 타입 안전성은 무엇이고, 왜 중요한가?
**타입 안전성(type safety)**은 프로그램의 한 부분이 객체를 해당 타입의 규칙에 따라서만 사용하도록 보장하는 것이다.
중유한 이유!
- 오류 방지: 컴파일러가 각 변수의 타입을 기억하고 올바르게 사용되는지 확인하여 많은 실수를 방지할 수 있다.
- 예측 가능성: 변수가 초기화되지 않거나, 타입에 맞지 않는 값이 할당되는 경우 예측 불가능한 동작을 초래할 수 있는데, 타입 안전성은 이러한 문제를 줄여 프로그램의 예측 가능성을 높인다.
- 코드 품질: 타입 안전성이 지켜지지 않는 코드는 종종 "형편없는" 프로그램으로 이어져, 디버깅에 많은 시간과 노력이 필요하게 된다.
### `double`을 `int`로 변환하면 나쁜점이 무엇인가?
`double`을 `int`로 변환할 때 `double`의 소수 부분(소수점 이하)이 단순히 버려져 정보 손실이 발생한다. 반올림 방식이 아니기 때문에 예상치 못한 결과가 나타날 수 있다.
### 한 타입을 다른 타입으로 변환할 때 그 변환이 안전한지 아닌지 결정하는데 도움을 줄 수 있는 규칙을 설명해보자.
값이 항상 동일한 값으로 변환되거나(예: int를 double로), 동등한 값의 최적 근사치로 변환되는 경우에 안전한 변환으로 볼 수 있다.
- `bool`에서 `char`, `int`, `double`
- `char`에서 `int`, `double`
- `int`에서 `double`
이렇게 비트가 적은 타입 -> 비트가 많은 타입으로 변환 할 때는 안전한 변환으로 볼 수 있다.
`double`에서 `int`, `char`, `bool`같이 큰 타입에서 더 작은 타입으로 변환할 때 안전하지 않은 변환으로 볼 수 있다.