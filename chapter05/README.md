# Chapter05 Error

## 복습문제

### 오류의 네 가지 주요 종류를 나열하고, 각각을 간략히 설명하라.
- 컴파일 시간 오류 : 컴파일러가 찾아낸 오류
- 링크 시간 오류 : 목적 파일을 실행 프로그램이 통합하는 과정에서 링커가 찾아낸 오류
- 실행 시간 오류 : 프로그램이 실행되는동안 확인된 오류
  - 컴퓨터(하드웨어나 운영체제)가 감지한 오류
  - 라이브러리가 감지한 오류
  - 사용자 코드가 감지한 오류
 - 논리 오류 : 프로그래머가 잘못된 결과의 원인을 분석하는 과정에서 찾아낸 오류
### 학습용 프로그램에서 무시해도 좋은 오류는 무엇이 있는가?
- 하드웨어의 오작동
- 시스템 소프트웨어의 오동작
- 오류를 감지한 후 프로그램 종료
### 완성된 프로젝트가 보장해야할 것은 무엇인가?
- 모든 적법한 입력에 대해 요구받은 결과를 생성
- 모든 적법하지 않은 입력에 대해 적절한 오류 메시지 생성
### 프로그램의 오류를 제거하고 수용 가능한 프로그램을 만드는 세 가지 접근 방법은 무엇인가?
- 소프트웨어를 조직화해서 오류를 최소화
- 우리가 만든 대부분의 오류를 테스트와 디버깅을 바탕으로 제거
- 남아있는 오류는 사소한 오류임을 확인
### 우리는 왜 디버깅을 싫어하는가?
디버깅 과정이 지루하고, 프로그래밍 관점에서 시간낭비라고 생각되기 때문.
### 문법 오류는 무엇인가? 다섯 가지 예를 들어보라.
c++문법에 부합하지 않는 코드를 컴파일러가 거부하여 나타나는 오류
```
int area(int length, int width); // 사각형 넓이 계산 함수
int s1 = area(7; // `)` 누락
int s2 = area(7) // `;` 누락
Int s3 = area(7); // Int는 타입이 아님
int s4 = area('7); // 종료하지 않은 문자 ('누락)
int s5 = area(7 2); // 인자 사이 `,`쉼표 누락
```
### 타입 오류는 무엇인가? 다섯 가지 예를 들어보라.
선언한(혹은 선언조차 되지 않은) 변수와 함수 등의 타입과 변수에 대입하려는 값이나 표현식, 함수에 건네준 인자 등의 타입이 일치하지 않은 경우
```
int x1 = arena(7); // 선언하지 않은 함수
int x2 = area(7); // 인자의 수가 맞지 않음
int x3 = area("seven", 2); // 첫번째 인자의 타입이 올바르지 않음
int x4 = area(7.5, 2); // 첫번째 인자의 타입이 올바르지 않음
string x5 = area(7); // 반환 타입이 일치하지 않음
```
### 링커오류는 무엇인가? 세 가지 예를 들어보라.
두가지 규칙 중 하나라도 위반하면 링커가 오류를 낸다.
- 한 프로그램 안의 모든 함수는 그 함수를 사용하는 모든 변환 단위에서 동일한 타입으로 선언돼야 한다. 이를 보장하기 위해 헤더 파일을 이용한다.
- 모든함수는 한 프로그램 안에서 딱 한 번 정의되야 한다.
```
int area(int x, int y); // "우리"가 호출한 area()
double area (double x, double y) {...} //"우리"가 호출한 area() 아님
int area (int x, int, char unit) {...} //"우리"가 호출한 area() 아님
char area(int x, int y) {...} //"우리"가 호출한 area() 아님
```
### 논리 오류는 무엇인가? 세 가지 예를 들어보라.
- 잘못된 연산자 사용 : 1+2*3을 (1+2)*3으로 계산하는 것처럼 연산자 우선순위를 고려하지 않고 코드를 작성하는 경우
- 잘못된 초기값 설정 : 예를 들어, 온도를 계산하는 프로그램에서 최저 온도의 초기값을 0.0으로 설정하여 모든 온도가 영상일 때 잘못된 최저 온도 값을 출력하는 경우
- 잘못된 주소 접근 : `i<=v.size()`와 같이 반복문의 종료 조건을 잘못 설정하여 벡터의 범위를 벗어나는 경우
### 본문에서 다룬 프로그램 오류의 잠재적 원인 네 가지를 들어보라.
- 엉터리 명세 : 프로그램이 해야 할 일을 정확하게 명시하지 않은 경우
- 불완전한 프로그램 : 개발 과정에서 고려하지 않은 경우가 있는 경우
- 예상 밖의 인자 : 우리가 처리하지 않은 인자가 함수에 전달 될 경우
- 논리 오류 : 코드가 의도한대로 작동하지 않는 경우
### 결과가 그럴듯한지 어떻게 알 수 있는가? 이에 답하려면 어떤 종류의 기법을 사용해야 하는가?
**추정**기법을 사용해야 한다. 적절한 계산과 추측을 조합한 개념이다.
결과값이 우리가 예상하는 범위(계산과 추측을 통한) 내에 있는지 대략적으로 확인한다.
### 함수를 호출하는 쪽에서 실행 시간 오류를 처리하는 방법과 호출된 함수 안에서 실행 시간 오류를 처리하는 방법을 비교/대조하라.
- 호출하는 쪽에서 처리 : 함수를 호출하기 전에 인자를 검사하여 오류를 처리하는 방식이다.
라이브러리 안에 포함된 함수여서 우리가 직접 수정할 수 없는 경우 선택한다.
이 방법은 함수의 내부 구현을 알아야 하고, 오류 처리 코드가 중복될 수 있다는 단점이 있다.
- 호출되는 쪽에서 처리 : 함수 내부에서 인자를 검사하고 오류를 처리하는 방식이다.
인자 확인 코드가 한곳에 모여있어 프로그램 전체를 훑어볼 필요가 없다는 장점이 있다.
라이브러리 함수처럼 수정이 불가능 한 경우에는 사용하기 어렵다.
### '오류 값'으 반환하는 방식보다 예외를 이용하는 방법이 더 좋은 이유는 무엇인가?
예외를 사용하면 오류가 난 부분을 받아서 무슨일을 할 지 정해 처리할 수 있다.
오류 값으로 프로그램을 종료 하면 모든 함수가 각자의 오류를 나타내는 특별한 오류 값을 갖기 어려워 오류 파악이 어려워 질 수 있다.
### 입력 연산이 성공했는지 확인하는 방법은 무엇인가?
`cin`과 같은 입력 스트림 객체는 입력 여산이 성공하면 `true`로 평가되고 실패하면 `false`로 평가된다.
```
if (cin)
  // 입력 성공
else
  // 입력 실패
```
### 예외를 던지고 잡는 과정을 설명하라.
1. 함수가 처리할 수 없는 오류가 발생하면 `return`대신 예외를 `throw`한다.
2. 문제의 함수를 직간접적으로 호출한 모든 함수에서 예외를 `catch`해서 호출된 코드가 `throw`를 사용했을 때 무슨일을 할 지 정한다.
3. 예외에 관심있는 함수에서는 `try`블록을 이요하여 예외의 종류를 `try`블록안의 `catch`부분에 나열한다.
4. 호출하는 쪽 어디에서도 예외를 잡지않으면 프로그램을 종료한다.
### `vector v`에 대해서 `v[v.size()]`가 구간오류인 이유는 무엇인가? 이 코드를 실행하면 무슨일이 벌어지는가?
`vector`의 인덱스는 0부터 v.size()-1 까지다.
`v[v-size()]`의 접근은 의도하지 않은 메모리 영역에 접근하게 되어 프로그램이 비정상적으로 종료되거나 예측할 수 없는 결과를 낳을 수 있다.
### 사전 조건과 사후 조건의 정의를 내리고, 예를 들어보자. 루프가 필요한 계산을 예로 들면 더 좋다.
- 사전 조건(Pre-condition): 함수가 올바르게 동작하기 위해 함수 호출 전에 만족해야 하는 조건이다.
예를 들어, 벡터의 모든 요소의 합을 구하는 함수의 사전 조건은 "벡터가 비어있지 않다"가 될 수 있다.
- 사후 조건(Post-condition): 함수가 실행된 후에 만족해야 하는 조건이다.
예를 들어, 위 함수의 사후 조건은 "반환된 합계는 벡터의 모든 요소를 더한 값과 같다"가 될 수 있다.
### 사전 조건을 확인하지 않는 경우는 언제인가?
사전조건을 확인하는 비용이 함수 실행 비용보다 훨씬 크거나, 사전 조건을 코드로 표한하기 매우 복잡한 경우에 확인하지 않을 수 있다.
### 사후조건을 확인하지 않는 경우는 언제이가?
함수가 매우 간단하여 사후 조건을 확인하는 것이 불필요하거나, 사후 조건을 확인하는 것이 매우 복잡하고 비용이 많이 드는 경우 확이하지 않을 수 있다.
### 프로그램을 디버깅하는 단계를 나열하자.
1. 프로그램을 컴파일한다.
2. 프로그램을 링크한다.
3. 프로그램이 의도대로 동작하게 한다.
### 디버깅 할 때 주석이 도움이 되는 이유는 무엇인가?
주석은 코드에서 잘 드러나지않은 사실, 의도를 설명해두어 프로그래머의 원래 의도를 파악하고 코드의 논리적 오류를 찾는데 도움을 받을 수 있다.
### 테스팅과 디버깅의 차이점은 무엇인가?
- 테스팅 : 오류를 찾기 위해 프로그램을 체계적으로 실행하는 과정
- 디버깅 : 이미 알려진 오류의 원인을 찾아 수정하는 과정
